// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transport.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_transport_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_transport_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_transport_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_transport_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_transport_2eproto;
class AppendEntriesRequest;
struct AppendEntriesRequestDefaultTypeInternal;
extern AppendEntriesRequestDefaultTypeInternal _AppendEntriesRequest_default_instance_;
class AppendEntriesResponse;
struct AppendEntriesResponseDefaultTypeInternal;
extern AppendEntriesResponseDefaultTypeInternal _AppendEntriesResponse_default_instance_;
class InstallSnapshotRequest;
struct InstallSnapshotRequestDefaultTypeInternal;
extern InstallSnapshotRequestDefaultTypeInternal _InstallSnapshotRequest_default_instance_;
class InstallSnapshotResponse;
struct InstallSnapshotResponseDefaultTypeInternal;
extern InstallSnapshotResponseDefaultTypeInternal _InstallSnapshotResponse_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class RPCHeader;
struct RPCHeaderDefaultTypeInternal;
extern RPCHeaderDefaultTypeInternal _RPCHeader_default_instance_;
class RequestVoteRequest;
struct RequestVoteRequestDefaultTypeInternal;
extern RequestVoteRequestDefaultTypeInternal _RequestVoteRequest_default_instance_;
class RequestVoteResponse;
struct RequestVoteResponseDefaultTypeInternal;
extern RequestVoteResponseDefaultTypeInternal _RequestVoteResponse_default_instance_;
class TimeoutNowRequest;
struct TimeoutNowRequestDefaultTypeInternal;
extern TimeoutNowRequestDefaultTypeInternal _TimeoutNowRequest_default_instance_;
class TimeoutNowResponse;
struct TimeoutNowResponseDefaultTypeInternal;
extern TimeoutNowResponseDefaultTypeInternal _TimeoutNowResponse_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum Log_LogType : int {
  Log_LogType_LOG_COMMAND = 0,
  Log_LogType_LOG_NOOP = 1,
  Log_LogType_LOG_ADD_PEER_DEPRECATED = 2,
  Log_LogType_LOG_REMOVE_PEER_DEPRECATED = 3,
  Log_LogType_LOG_BARRIER = 4,
  Log_LogType_LOG_CONFIGURATION = 5,
  Log_LogType_Log_LogType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Log_LogType_Log_LogType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Log_LogType_IsValid(int value);
extern const uint32_t Log_LogType_internal_data_[];
constexpr Log_LogType Log_LogType_LogType_MIN = static_cast<Log_LogType>(0);
constexpr Log_LogType Log_LogType_LogType_MAX = static_cast<Log_LogType>(5);
constexpr int Log_LogType_LogType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
Log_LogType_descriptor();
template <typename T>
const std::string& Log_LogType_Name(T value) {
  static_assert(std::is_same<T, Log_LogType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LogType_Name().");
  return Log_LogType_Name(static_cast<Log_LogType>(value));
}
template <>
inline const std::string& Log_LogType_Name(Log_LogType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Log_LogType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool Log_LogType_Parse(absl::string_view name, Log_LogType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Log_LogType>(
      Log_LogType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RPCHeader final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RPCHeader) */ {
 public:
  inline RPCHeader() : RPCHeader(nullptr) {}
  ~RPCHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RPCHeader(::google::protobuf::internal::ConstantInitialized);

  inline RPCHeader(const RPCHeader& from)
      : RPCHeader(nullptr, from) {}
  RPCHeader(RPCHeader&& from) noexcept
    : RPCHeader() {
    *this = ::std::move(from);
  }

  inline RPCHeader& operator=(const RPCHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RPCHeader& operator=(RPCHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RPCHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RPCHeader* internal_default_instance() {
    return reinterpret_cast<const RPCHeader*>(
               &_RPCHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RPCHeader& a, RPCHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RPCHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RPCHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RPCHeader* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RPCHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RPCHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RPCHeader& from) {
    RPCHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RPCHeader* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "RPCHeader";
  }
  protected:
  explicit RPCHeader(::google::protobuf::Arena* arena);
  RPCHeader(::google::protobuf::Arena* arena, const RPCHeader& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kAddrFieldNumber = 3,
    kProtocolVersionFieldNumber = 1,
  };
  // bytes id = 2;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // bytes addr = 3;
  void clear_addr() ;
  const std::string& addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_addr(Arg_&& arg, Args_... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* value);

  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(
      const std::string& value);
  std::string* _internal_mutable_addr();

  public:
  // int64 protocol_version = 1;
  void clear_protocol_version() ;
  ::int64_t protocol_version() const;
  void set_protocol_version(::int64_t value);

  private:
  ::int64_t _internal_protocol_version() const;
  void _internal_set_protocol_version(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:RPCHeader)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr addr_;
    ::int64_t protocol_version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class TimeoutNowResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TimeoutNowResponse) */ {
 public:
  inline TimeoutNowResponse() : TimeoutNowResponse(nullptr) {}
  ~TimeoutNowResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeoutNowResponse(::google::protobuf::internal::ConstantInitialized);

  inline TimeoutNowResponse(const TimeoutNowResponse& from)
      : TimeoutNowResponse(nullptr, from) {}
  TimeoutNowResponse(TimeoutNowResponse&& from) noexcept
    : TimeoutNowResponse() {
    *this = ::std::move(from);
  }

  inline TimeoutNowResponse& operator=(const TimeoutNowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeoutNowResponse& operator=(TimeoutNowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeoutNowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeoutNowResponse* internal_default_instance() {
    return reinterpret_cast<const TimeoutNowResponse*>(
               &_TimeoutNowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TimeoutNowResponse& a, TimeoutNowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeoutNowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeoutNowResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeoutNowResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeoutNowResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeoutNowResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TimeoutNowResponse& from) {
    TimeoutNowResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimeoutNowResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TimeoutNowResponse";
  }
  protected:
  explicit TimeoutNowResponse(::google::protobuf::Arena* arena);
  TimeoutNowResponse(::google::protobuf::Arena* arena, const TimeoutNowResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpcHeaderFieldNumber = 1,
  };
  // .RPCHeader rpc_header = 1;
  bool has_rpc_header() const;
  void clear_rpc_header() ;
  const ::RPCHeader& rpc_header() const;
  PROTOBUF_NODISCARD ::RPCHeader* release_rpc_header();
  ::RPCHeader* mutable_rpc_header();
  void set_allocated_rpc_header(::RPCHeader* value);
  void unsafe_arena_set_allocated_rpc_header(::RPCHeader* value);
  ::RPCHeader* unsafe_arena_release_rpc_header();

  private:
  const ::RPCHeader& _internal_rpc_header() const;
  ::RPCHeader* _internal_mutable_rpc_header();

  public:
  // @@protoc_insertion_point(class_scope:TimeoutNowResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::RPCHeader* rpc_header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class TimeoutNowRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TimeoutNowRequest) */ {
 public:
  inline TimeoutNowRequest() : TimeoutNowRequest(nullptr) {}
  ~TimeoutNowRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeoutNowRequest(::google::protobuf::internal::ConstantInitialized);

  inline TimeoutNowRequest(const TimeoutNowRequest& from)
      : TimeoutNowRequest(nullptr, from) {}
  TimeoutNowRequest(TimeoutNowRequest&& from) noexcept
    : TimeoutNowRequest() {
    *this = ::std::move(from);
  }

  inline TimeoutNowRequest& operator=(const TimeoutNowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeoutNowRequest& operator=(TimeoutNowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeoutNowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeoutNowRequest* internal_default_instance() {
    return reinterpret_cast<const TimeoutNowRequest*>(
               &_TimeoutNowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TimeoutNowRequest& a, TimeoutNowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeoutNowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeoutNowRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeoutNowRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeoutNowRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeoutNowRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TimeoutNowRequest& from) {
    TimeoutNowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimeoutNowRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "TimeoutNowRequest";
  }
  protected:
  explicit TimeoutNowRequest(::google::protobuf::Arena* arena);
  TimeoutNowRequest(::google::protobuf::Arena* arena, const TimeoutNowRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpcHeaderFieldNumber = 1,
  };
  // .RPCHeader rpc_header = 1;
  bool has_rpc_header() const;
  void clear_rpc_header() ;
  const ::RPCHeader& rpc_header() const;
  PROTOBUF_NODISCARD ::RPCHeader* release_rpc_header();
  ::RPCHeader* mutable_rpc_header();
  void set_allocated_rpc_header(::RPCHeader* value);
  void unsafe_arena_set_allocated_rpc_header(::RPCHeader* value);
  ::RPCHeader* unsafe_arena_release_rpc_header();

  private:
  const ::RPCHeader& _internal_rpc_header() const;
  ::RPCHeader* _internal_mutable_rpc_header();

  public:
  // @@protoc_insertion_point(class_scope:TimeoutNowRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::RPCHeader* rpc_header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class RequestVoteResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestVoteResponse) */ {
 public:
  inline RequestVoteResponse() : RequestVoteResponse(nullptr) {}
  ~RequestVoteResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestVoteResponse(::google::protobuf::internal::ConstantInitialized);

  inline RequestVoteResponse(const RequestVoteResponse& from)
      : RequestVoteResponse(nullptr, from) {}
  RequestVoteResponse(RequestVoteResponse&& from) noexcept
    : RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline RequestVoteResponse& operator=(const RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteResponse& operator=(RequestVoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const RequestVoteResponse*>(
               &_RequestVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RequestVoteResponse& a, RequestVoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestVoteResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestVoteResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestVoteResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestVoteResponse& from) {
    RequestVoteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RequestVoteResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "RequestVoteResponse";
  }
  protected:
  explicit RequestVoteResponse(::google::protobuf::Arena* arena);
  RequestVoteResponse(::google::protobuf::Arena* arena, const RequestVoteResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 3,
    kRpcHeaderFieldNumber = 1,
    kTermFieldNumber = 2,
    kGrantedFieldNumber = 4,
  };
  // bytes peers = 3;
  void clear_peers() ;
  const std::string& peers() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_peers(Arg_&& arg, Args_... args);
  std::string* mutable_peers();
  PROTOBUF_NODISCARD std::string* release_peers();
  void set_allocated_peers(std::string* value);

  private:
  const std::string& _internal_peers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peers(
      const std::string& value);
  std::string* _internal_mutable_peers();

  public:
  // .RPCHeader rpc_header = 1;
  bool has_rpc_header() const;
  void clear_rpc_header() ;
  const ::RPCHeader& rpc_header() const;
  PROTOBUF_NODISCARD ::RPCHeader* release_rpc_header();
  ::RPCHeader* mutable_rpc_header();
  void set_allocated_rpc_header(::RPCHeader* value);
  void unsafe_arena_set_allocated_rpc_header(::RPCHeader* value);
  ::RPCHeader* unsafe_arena_release_rpc_header();

  private:
  const ::RPCHeader& _internal_rpc_header() const;
  ::RPCHeader* _internal_mutable_rpc_header();

  public:
  // uint64 term = 2;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // bool granted = 4;
  void clear_granted() ;
  bool granted() const;
  void set_granted(bool value);

  private:
  bool _internal_granted() const;
  void _internal_set_granted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RequestVoteResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr peers_;
    ::RPCHeader* rpc_header_;
    ::uint64_t term_;
    bool granted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class RequestVoteRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestVoteRequest) */ {
 public:
  inline RequestVoteRequest() : RequestVoteRequest(nullptr) {}
  ~RequestVoteRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestVoteRequest(::google::protobuf::internal::ConstantInitialized);

  inline RequestVoteRequest(const RequestVoteRequest& from)
      : RequestVoteRequest(nullptr, from) {}
  RequestVoteRequest(RequestVoteRequest&& from) noexcept
    : RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline RequestVoteRequest& operator=(const RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteRequest& operator=(RequestVoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const RequestVoteRequest*>(
               &_RequestVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestVoteRequest& a, RequestVoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestVoteRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestVoteRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestVoteRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestVoteRequest& from) {
    RequestVoteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RequestVoteRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "RequestVoteRequest";
  }
  protected:
  explicit RequestVoteRequest(::google::protobuf::Arena* arena);
  RequestVoteRequest(::google::protobuf::Arena* arena, const RequestVoteRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 3,
    kRpcHeaderFieldNumber = 1,
    kTermFieldNumber = 2,
    kLastLogIndexFieldNumber = 4,
    kLastLogTermFieldNumber = 5,
    kLeadershipTransferFieldNumber = 6,
  };
  // bytes candidate = 3;
  void clear_candidate() ;
  const std::string& candidate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_candidate(Arg_&& arg, Args_... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* value);

  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(
      const std::string& value);
  std::string* _internal_mutable_candidate();

  public:
  // .RPCHeader rpc_header = 1;
  bool has_rpc_header() const;
  void clear_rpc_header() ;
  const ::RPCHeader& rpc_header() const;
  PROTOBUF_NODISCARD ::RPCHeader* release_rpc_header();
  ::RPCHeader* mutable_rpc_header();
  void set_allocated_rpc_header(::RPCHeader* value);
  void unsafe_arena_set_allocated_rpc_header(::RPCHeader* value);
  ::RPCHeader* unsafe_arena_release_rpc_header();

  private:
  const ::RPCHeader& _internal_rpc_header() const;
  ::RPCHeader* _internal_mutable_rpc_header();

  public:
  // uint64 term = 2;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // uint64 last_log_index = 4;
  void clear_last_log_index() ;
  ::uint64_t last_log_index() const;
  void set_last_log_index(::uint64_t value);

  private:
  ::uint64_t _internal_last_log_index() const;
  void _internal_set_last_log_index(::uint64_t value);

  public:
  // uint64 last_log_term = 5;
  void clear_last_log_term() ;
  ::uint64_t last_log_term() const;
  void set_last_log_term(::uint64_t value);

  private:
  ::uint64_t _internal_last_log_term() const;
  void _internal_set_last_log_term(::uint64_t value);

  public:
  // bool leadership_transfer = 6;
  void clear_leadership_transfer() ;
  bool leadership_transfer() const;
  void set_leadership_transfer(bool value);

  private:
  bool _internal_leadership_transfer() const;
  void _internal_set_leadership_transfer(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RequestVoteRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr candidate_;
    ::RPCHeader* rpc_header_;
    ::uint64_t term_;
    ::uint64_t last_log_index_;
    ::uint64_t last_log_term_;
    bool leadership_transfer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class Log final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Log(::google::protobuf::internal::ConstantInitialized);

  inline Log(const Log& from)
      : Log(nullptr, from) {}
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Log* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Log";
  }
  protected:
  explicit Log(::google::protobuf::Arena* arena);
  Log(::google::protobuf::Arena* arena, const Log& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LogType = Log_LogType;
  static constexpr LogType LOG_COMMAND = Log_LogType_LOG_COMMAND;
  static constexpr LogType LOG_NOOP = Log_LogType_LOG_NOOP;
  static constexpr LogType LOG_ADD_PEER_DEPRECATED = Log_LogType_LOG_ADD_PEER_DEPRECATED;
  static constexpr LogType LOG_REMOVE_PEER_DEPRECATED = Log_LogType_LOG_REMOVE_PEER_DEPRECATED;
  static constexpr LogType LOG_BARRIER = Log_LogType_LOG_BARRIER;
  static constexpr LogType LOG_CONFIGURATION = Log_LogType_LOG_CONFIGURATION;
  static inline bool LogType_IsValid(int value) {
    return Log_LogType_IsValid(value);
  }
  static constexpr LogType LogType_MIN = Log_LogType_LogType_MIN;
  static constexpr LogType LogType_MAX = Log_LogType_LogType_MAX;
  static constexpr int LogType_ARRAYSIZE = Log_LogType_LogType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LogType_descriptor() {
    return Log_LogType_descriptor();
  }
  template <typename T>
  static inline const std::string& LogType_Name(T value) {
    return Log_LogType_Name(value);
  }
  static inline bool LogType_Parse(absl::string_view name, LogType* value) {
    return Log_LogType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kExtensionsFieldNumber = 5,
    kAppendedAtFieldNumber = 6,
    kIndexFieldNumber = 1,
    kTermFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // bytes data = 4;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // bytes extensions = 5;
  void clear_extensions() ;
  const std::string& extensions() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extensions(Arg_&& arg, Args_... args);
  std::string* mutable_extensions();
  PROTOBUF_NODISCARD std::string* release_extensions();
  void set_allocated_extensions(std::string* value);

  private:
  const std::string& _internal_extensions() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extensions(
      const std::string& value);
  std::string* _internal_mutable_extensions();

  public:
  // .google.protobuf.Timestamp appended_at = 6;
  bool has_appended_at() const;
  void clear_appended_at() ;
  const ::google::protobuf::Timestamp& appended_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_appended_at();
  ::google::protobuf::Timestamp* mutable_appended_at();
  void set_allocated_appended_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_appended_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_appended_at();

  private:
  const ::google::protobuf::Timestamp& _internal_appended_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_appended_at();

  public:
  // uint64 index = 1;
  void clear_index() ;
  ::uint64_t index() const;
  void set_index(::uint64_t value);

  private:
  ::uint64_t _internal_index() const;
  void _internal_set_index(::uint64_t value);

  public:
  // uint64 term = 2;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // .Log.LogType type = 3;
  void clear_type() ;
  ::Log_LogType type() const;
  void set_type(::Log_LogType value);

  private:
  ::Log_LogType _internal_type() const;
  void _internal_set_type(::Log_LogType value);

  public:
  // @@protoc_insertion_point(class_scope:Log)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr extensions_;
    ::google::protobuf::Timestamp* appended_at_;
    ::uint64_t index_;
    ::uint64_t term_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class InstallSnapshotResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InstallSnapshotResponse) */ {
 public:
  inline InstallSnapshotResponse() : InstallSnapshotResponse(nullptr) {}
  ~InstallSnapshotResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstallSnapshotResponse(::google::protobuf::internal::ConstantInitialized);

  inline InstallSnapshotResponse(const InstallSnapshotResponse& from)
      : InstallSnapshotResponse(nullptr, from) {}
  InstallSnapshotResponse(InstallSnapshotResponse&& from) noexcept
    : InstallSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline InstallSnapshotResponse& operator=(const InstallSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallSnapshotResponse& operator=(InstallSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const InstallSnapshotResponse*>(
               &_InstallSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InstallSnapshotResponse& a, InstallSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallSnapshotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallSnapshotResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallSnapshotResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstallSnapshotResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InstallSnapshotResponse& from) {
    InstallSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InstallSnapshotResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "InstallSnapshotResponse";
  }
  protected:
  explicit InstallSnapshotResponse(::google::protobuf::Arena* arena);
  InstallSnapshotResponse(::google::protobuf::Arena* arena, const InstallSnapshotResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpcHeaderFieldNumber = 1,
    kTermFieldNumber = 2,
    kSuccessFieldNumber = 3,
  };
  // .RPCHeader rpc_header = 1;
  bool has_rpc_header() const;
  void clear_rpc_header() ;
  const ::RPCHeader& rpc_header() const;
  PROTOBUF_NODISCARD ::RPCHeader* release_rpc_header();
  ::RPCHeader* mutable_rpc_header();
  void set_allocated_rpc_header(::RPCHeader* value);
  void unsafe_arena_set_allocated_rpc_header(::RPCHeader* value);
  ::RPCHeader* unsafe_arena_release_rpc_header();

  private:
  const ::RPCHeader& _internal_rpc_header() const;
  ::RPCHeader* _internal_mutable_rpc_header();

  public:
  // uint64 term = 2;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:InstallSnapshotResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::RPCHeader* rpc_header_;
    ::uint64_t term_;
    bool success_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class InstallSnapshotRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InstallSnapshotRequest) */ {
 public:
  inline InstallSnapshotRequest() : InstallSnapshotRequest(nullptr) {}
  ~InstallSnapshotRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstallSnapshotRequest(::google::protobuf::internal::ConstantInitialized);

  inline InstallSnapshotRequest(const InstallSnapshotRequest& from)
      : InstallSnapshotRequest(nullptr, from) {}
  InstallSnapshotRequest(InstallSnapshotRequest&& from) noexcept
    : InstallSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline InstallSnapshotRequest& operator=(const InstallSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallSnapshotRequest& operator=(InstallSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const InstallSnapshotRequest*>(
               &_InstallSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InstallSnapshotRequest& a, InstallSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallSnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallSnapshotRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallSnapshotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstallSnapshotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InstallSnapshotRequest& from) {
    InstallSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InstallSnapshotRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "InstallSnapshotRequest";
  }
  protected:
  explicit InstallSnapshotRequest(::google::protobuf::Arena* arena);
  InstallSnapshotRequest(::google::protobuf::Arena* arena, const InstallSnapshotRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderFieldNumber = 3,
    kPeersFieldNumber = 6,
    kConfigurationFieldNumber = 7,
    kDataFieldNumber = 10,
    kRpcHeaderFieldNumber = 1,
    kTermFieldNumber = 2,
    kLastLogIndexFieldNumber = 4,
    kLastLogTermFieldNumber = 5,
    kConfigurationIndexFieldNumber = 8,
    kSizeFieldNumber = 9,
    kSnapshotVersionFieldNumber = 11,
  };
  // bytes leader = 3;
  void clear_leader() ;
  const std::string& leader() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_leader(Arg_&& arg, Args_... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* value);

  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(
      const std::string& value);
  std::string* _internal_mutable_leader();

  public:
  // bytes peers = 6;
  void clear_peers() ;
  const std::string& peers() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_peers(Arg_&& arg, Args_... args);
  std::string* mutable_peers();
  PROTOBUF_NODISCARD std::string* release_peers();
  void set_allocated_peers(std::string* value);

  private:
  const std::string& _internal_peers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peers(
      const std::string& value);
  std::string* _internal_mutable_peers();

  public:
  // bytes configuration = 7;
  void clear_configuration() ;
  const std::string& configuration() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_configuration(Arg_&& arg, Args_... args);
  std::string* mutable_configuration();
  PROTOBUF_NODISCARD std::string* release_configuration();
  void set_allocated_configuration(std::string* value);

  private:
  const std::string& _internal_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configuration(
      const std::string& value);
  std::string* _internal_mutable_configuration();

  public:
  // bytes data = 10;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // .RPCHeader rpc_header = 1;
  bool has_rpc_header() const;
  void clear_rpc_header() ;
  const ::RPCHeader& rpc_header() const;
  PROTOBUF_NODISCARD ::RPCHeader* release_rpc_header();
  ::RPCHeader* mutable_rpc_header();
  void set_allocated_rpc_header(::RPCHeader* value);
  void unsafe_arena_set_allocated_rpc_header(::RPCHeader* value);
  ::RPCHeader* unsafe_arena_release_rpc_header();

  private:
  const ::RPCHeader& _internal_rpc_header() const;
  ::RPCHeader* _internal_mutable_rpc_header();

  public:
  // uint64 term = 2;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // uint64 last_log_index = 4;
  void clear_last_log_index() ;
  ::uint64_t last_log_index() const;
  void set_last_log_index(::uint64_t value);

  private:
  ::uint64_t _internal_last_log_index() const;
  void _internal_set_last_log_index(::uint64_t value);

  public:
  // uint64 last_log_term = 5;
  void clear_last_log_term() ;
  ::uint64_t last_log_term() const;
  void set_last_log_term(::uint64_t value);

  private:
  ::uint64_t _internal_last_log_term() const;
  void _internal_set_last_log_term(::uint64_t value);

  public:
  // uint64 configuration_index = 8;
  void clear_configuration_index() ;
  ::uint64_t configuration_index() const;
  void set_configuration_index(::uint64_t value);

  private:
  ::uint64_t _internal_configuration_index() const;
  void _internal_set_configuration_index(::uint64_t value);

  public:
  // int64 size = 9;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // int64 snapshot_version = 11;
  void clear_snapshot_version() ;
  ::int64_t snapshot_version() const;
  void set_snapshot_version(::int64_t value);

  private:
  ::int64_t _internal_snapshot_version() const;
  void _internal_set_snapshot_version(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:InstallSnapshotRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr leader_;
    ::google::protobuf::internal::ArenaStringPtr peers_;
    ::google::protobuf::internal::ArenaStringPtr configuration_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::RPCHeader* rpc_header_;
    ::uint64_t term_;
    ::uint64_t last_log_index_;
    ::uint64_t last_log_term_;
    ::uint64_t configuration_index_;
    ::int64_t size_;
    ::int64_t snapshot_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class AppendEntriesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AppendEntriesResponse) */ {
 public:
  inline AppendEntriesResponse() : AppendEntriesResponse(nullptr) {}
  ~AppendEntriesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AppendEntriesResponse(::google::protobuf::internal::ConstantInitialized);

  inline AppendEntriesResponse(const AppendEntriesResponse& from)
      : AppendEntriesResponse(nullptr, from) {}
  AppendEntriesResponse(AppendEntriesResponse&& from) noexcept
    : AppendEntriesResponse() {
    *this = ::std::move(from);
  }

  inline AppendEntriesResponse& operator=(const AppendEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesResponse& operator=(AppendEntriesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesResponse* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesResponse*>(
               &_AppendEntriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AppendEntriesResponse& a, AppendEntriesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AppendEntriesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AppendEntriesResponse& from) {
    AppendEntriesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AppendEntriesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "AppendEntriesResponse";
  }
  protected:
  explicit AppendEntriesResponse(::google::protobuf::Arena* arena);
  AppendEntriesResponse(::google::protobuf::Arena* arena, const AppendEntriesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpcHeaderFieldNumber = 1,
    kTermFieldNumber = 2,
    kLastLogFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kNoRetryBackoffFieldNumber = 5,
  };
  // .RPCHeader rpc_header = 1;
  bool has_rpc_header() const;
  void clear_rpc_header() ;
  const ::RPCHeader& rpc_header() const;
  PROTOBUF_NODISCARD ::RPCHeader* release_rpc_header();
  ::RPCHeader* mutable_rpc_header();
  void set_allocated_rpc_header(::RPCHeader* value);
  void unsafe_arena_set_allocated_rpc_header(::RPCHeader* value);
  ::RPCHeader* unsafe_arena_release_rpc_header();

  private:
  const ::RPCHeader& _internal_rpc_header() const;
  ::RPCHeader* _internal_mutable_rpc_header();

  public:
  // uint64 term = 2;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // uint64 last_log = 3;
  void clear_last_log() ;
  ::uint64_t last_log() const;
  void set_last_log(::uint64_t value);

  private:
  ::uint64_t _internal_last_log() const;
  void _internal_set_last_log(::uint64_t value);

  public:
  // bool success = 4;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // bool no_retry_backoff = 5;
  void clear_no_retry_backoff() ;
  bool no_retry_backoff() const;
  void set_no_retry_backoff(bool value);

  private:
  bool _internal_no_retry_backoff() const;
  void _internal_set_no_retry_backoff(bool value);

  public:
  // @@protoc_insertion_point(class_scope:AppendEntriesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::RPCHeader* rpc_header_;
    ::uint64_t term_;
    ::uint64_t last_log_;
    bool success_;
    bool no_retry_backoff_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};// -------------------------------------------------------------------

class AppendEntriesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AppendEntriesRequest) */ {
 public:
  inline AppendEntriesRequest() : AppendEntriesRequest(nullptr) {}
  ~AppendEntriesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AppendEntriesRequest(::google::protobuf::internal::ConstantInitialized);

  inline AppendEntriesRequest(const AppendEntriesRequest& from)
      : AppendEntriesRequest(nullptr, from) {}
  AppendEntriesRequest(AppendEntriesRequest&& from) noexcept
    : AppendEntriesRequest() {
    *this = ::std::move(from);
  }

  inline AppendEntriesRequest& operator=(const AppendEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesRequest& operator=(AppendEntriesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesRequest*>(
               &_AppendEntriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AppendEntriesRequest& a, AppendEntriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AppendEntriesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AppendEntriesRequest& from) {
    AppendEntriesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AppendEntriesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "AppendEntriesRequest";
  }
  protected:
  explicit AppendEntriesRequest(::google::protobuf::Arena* arena);
  AppendEntriesRequest(::google::protobuf::Arena* arena, const AppendEntriesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 6,
    kLeaderFieldNumber = 3,
    kRpcHeaderFieldNumber = 1,
    kTermFieldNumber = 2,
    kPrevLogEntryFieldNumber = 4,
    kPrevLogTermFieldNumber = 5,
    kLeaderCommitIndexFieldNumber = 7,
  };
  // repeated .Log entries = 6;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::Log* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::Log >*
      mutable_entries();
  private:
  const ::google::protobuf::RepeatedPtrField<::Log>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::Log>* _internal_mutable_entries();
  public:
  const ::Log& entries(int index) const;
  ::Log* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::Log >&
      entries() const;
  // bytes leader = 3;
  void clear_leader() ;
  const std::string& leader() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_leader(Arg_&& arg, Args_... args);
  std::string* mutable_leader();
  PROTOBUF_NODISCARD std::string* release_leader();
  void set_allocated_leader(std::string* value);

  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(
      const std::string& value);
  std::string* _internal_mutable_leader();

  public:
  // .RPCHeader rpc_header = 1;
  bool has_rpc_header() const;
  void clear_rpc_header() ;
  const ::RPCHeader& rpc_header() const;
  PROTOBUF_NODISCARD ::RPCHeader* release_rpc_header();
  ::RPCHeader* mutable_rpc_header();
  void set_allocated_rpc_header(::RPCHeader* value);
  void unsafe_arena_set_allocated_rpc_header(::RPCHeader* value);
  ::RPCHeader* unsafe_arena_release_rpc_header();

  private:
  const ::RPCHeader& _internal_rpc_header() const;
  ::RPCHeader* _internal_mutable_rpc_header();

  public:
  // uint64 term = 2;
  void clear_term() ;
  ::uint64_t term() const;
  void set_term(::uint64_t value);

  private:
  ::uint64_t _internal_term() const;
  void _internal_set_term(::uint64_t value);

  public:
  // uint64 prev_log_entry = 4;
  void clear_prev_log_entry() ;
  ::uint64_t prev_log_entry() const;
  void set_prev_log_entry(::uint64_t value);

  private:
  ::uint64_t _internal_prev_log_entry() const;
  void _internal_set_prev_log_entry(::uint64_t value);

  public:
  // uint64 prev_log_term = 5;
  void clear_prev_log_term() ;
  ::uint64_t prev_log_term() const;
  void set_prev_log_term(::uint64_t value);

  private:
  ::uint64_t _internal_prev_log_term() const;
  void _internal_set_prev_log_term(::uint64_t value);

  public:
  // uint64 leader_commit_index = 7;
  void clear_leader_commit_index() ;
  ::uint64_t leader_commit_index() const;
  void set_leader_commit_index(::uint64_t value);

  private:
  ::uint64_t _internal_leader_commit_index() const;
  void _internal_set_leader_commit_index(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:AppendEntriesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::Log > entries_;
    ::google::protobuf::internal::ArenaStringPtr leader_;
    ::RPCHeader* rpc_header_;
    ::uint64_t term_;
    ::uint64_t prev_log_entry_;
    ::uint64_t prev_log_term_;
    ::uint64_t leader_commit_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RPCHeader

// int64 protocol_version = 1;
inline void RPCHeader::clear_protocol_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_version_ = ::int64_t{0};
}
inline ::int64_t RPCHeader::protocol_version() const {
  // @@protoc_insertion_point(field_get:RPCHeader.protocol_version)
  return _internal_protocol_version();
}
inline void RPCHeader::set_protocol_version(::int64_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:RPCHeader.protocol_version)
}
inline ::int64_t RPCHeader::_internal_protocol_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_version_;
}
inline void RPCHeader::_internal_set_protocol_version(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.protocol_version_ = value;
}

// bytes id = 2;
inline void RPCHeader::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RPCHeader::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RPCHeader.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RPCHeader::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RPCHeader.id)
}
inline std::string* RPCHeader::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:RPCHeader.id)
  return _s;
}
inline const std::string& RPCHeader::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void RPCHeader::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* RPCHeader::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* RPCHeader::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RPCHeader.id)
  return _impl_.id_.Release();
}
inline void RPCHeader::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPCHeader.id)
}

// bytes addr = 3;
inline void RPCHeader::clear_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& RPCHeader::addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RPCHeader.addr)
  return _internal_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RPCHeader::set_addr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RPCHeader.addr)
}
inline std::string* RPCHeader::mutable_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:RPCHeader.addr)
  return _s;
}
inline const std::string& RPCHeader::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_.Get();
}
inline void RPCHeader::_internal_set_addr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.addr_.Set(value, GetArena());
}
inline std::string* RPCHeader::_internal_mutable_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.addr_.Mutable( GetArena());
}
inline std::string* RPCHeader::release_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RPCHeader.addr)
  return _impl_.addr_.Release();
}
inline void RPCHeader::set_allocated_addr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.addr_.IsDefault()) {
          _impl_.addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPCHeader.addr)
}

// -------------------------------------------------------------------

// Log

// uint64 index = 1;
inline void Log::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = ::uint64_t{0u};
}
inline ::uint64_t Log::index() const {
  // @@protoc_insertion_point(field_get:Log.index)
  return _internal_index();
}
inline void Log::set_index(::uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:Log.index)
}
inline ::uint64_t Log::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void Log::_internal_set_index(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.index_ = value;
}

// uint64 term = 2;
inline void Log::clear_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.term_ = ::uint64_t{0u};
}
inline ::uint64_t Log::term() const {
  // @@protoc_insertion_point(field_get:Log.term)
  return _internal_term();
}
inline void Log::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:Log.term)
}
inline ::uint64_t Log::_internal_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.term_;
}
inline void Log::_internal_set_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.term_ = value;
}

// .Log.LogType type = 3;
inline void Log::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::Log_LogType Log::type() const {
  // @@protoc_insertion_point(field_get:Log.type)
  return _internal_type();
}
inline void Log::set_type(::Log_LogType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Log.type)
}
inline ::Log_LogType Log::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::Log_LogType>(_impl_.type_);
}
inline void Log::_internal_set_type(::Log_LogType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// bytes data = 4;
inline void Log::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Log::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Log.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Log::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Log.data)
}
inline std::string* Log::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Log.data)
  return _s;
}
inline const std::string& Log::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void Log::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Log::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Log::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Log.data)
  return _impl_.data_.Release();
}
inline void Log::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Log.data)
}

// bytes extensions = 5;
inline void Log::clear_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extensions_.ClearToEmpty();
}
inline const std::string& Log::extensions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Log.extensions)
  return _internal_extensions();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Log::set_extensions(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extensions_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Log.extensions)
}
inline std::string* Log::mutable_extensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extensions();
  // @@protoc_insertion_point(field_mutable:Log.extensions)
  return _s;
}
inline const std::string& Log::_internal_extensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extensions_.Get();
}
inline void Log::_internal_set_extensions(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extensions_.Set(value, GetArena());
}
inline std::string* Log::_internal_mutable_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.extensions_.Mutable( GetArena());
}
inline std::string* Log::release_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Log.extensions)
  return _impl_.extensions_.Release();
}
inline void Log::set_allocated_extensions(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extensions_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extensions_.IsDefault()) {
          _impl_.extensions_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Log.extensions)
}

// .google.protobuf.Timestamp appended_at = 6;
inline bool Log::has_appended_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.appended_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Log::_internal_appended_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.appended_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Log::appended_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Log.appended_at)
  return _internal_appended_at();
}
inline void Log::unsafe_arena_set_allocated_appended_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.appended_at_);
  }
  _impl_.appended_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Log.appended_at)
}
inline ::google::protobuf::Timestamp* Log::release_appended_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.appended_at_;
  _impl_.appended_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Log::unsafe_arena_release_appended_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Log.appended_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.appended_at_;
  _impl_.appended_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Log::_internal_mutable_appended_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.appended_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.appended_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.appended_at_;
}
inline ::google::protobuf::Timestamp* Log::mutable_appended_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_appended_at();
  // @@protoc_insertion_point(field_mutable:Log.appended_at)
  return _msg;
}
inline void Log::set_allocated_appended_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.appended_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.appended_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:Log.appended_at)
}

// -------------------------------------------------------------------

// AppendEntriesRequest

// .RPCHeader rpc_header = 1;
inline bool AppendEntriesRequest::has_rpc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_header_ != nullptr);
  return value;
}
inline void AppendEntriesRequest::clear_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_header_ != nullptr) _impl_.rpc_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::RPCHeader& AppendEntriesRequest::_internal_rpc_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::RPCHeader* p = _impl_.rpc_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::RPCHeader&>(::_RPCHeader_default_instance_);
}
inline const ::RPCHeader& AppendEntriesRequest::rpc_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AppendEntriesRequest.rpc_header)
  return _internal_rpc_header();
}
inline void AppendEntriesRequest::unsafe_arena_set_allocated_rpc_header(::RPCHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_header_);
  }
  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AppendEntriesRequest.rpc_header)
}
inline ::RPCHeader* AppendEntriesRequest::release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* released = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::RPCHeader* AppendEntriesRequest::unsafe_arena_release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:AppendEntriesRequest.rpc_header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* temp = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
  return temp;
}
inline ::RPCHeader* AppendEntriesRequest::_internal_mutable_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rpc_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::RPCHeader>(GetArena());
    _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(p);
  }
  return _impl_.rpc_header_;
}
inline ::RPCHeader* AppendEntriesRequest::mutable_rpc_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RPCHeader* _msg = _internal_mutable_rpc_header();
  // @@protoc_insertion_point(field_mutable:AppendEntriesRequest.rpc_header)
  return _msg;
}
inline void AppendEntriesRequest::set_allocated_rpc_header(::RPCHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::RPCHeader*>(_impl_.rpc_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::RPCHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:AppendEntriesRequest.rpc_header)
}

// uint64 term = 2;
inline void AppendEntriesRequest::clear_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.term_ = ::uint64_t{0u};
}
inline ::uint64_t AppendEntriesRequest::term() const {
  // @@protoc_insertion_point(field_get:AppendEntriesRequest.term)
  return _internal_term();
}
inline void AppendEntriesRequest::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:AppendEntriesRequest.term)
}
inline ::uint64_t AppendEntriesRequest::_internal_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.term_;
}
inline void AppendEntriesRequest::_internal_set_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.term_ = value;
}

// bytes leader = 3;
inline void AppendEntriesRequest::clear_leader() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leader_.ClearToEmpty();
}
inline const std::string& AppendEntriesRequest::leader() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AppendEntriesRequest.leader)
  return _internal_leader();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AppendEntriesRequest::set_leader(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leader_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:AppendEntriesRequest.leader)
}
inline std::string* AppendEntriesRequest::mutable_leader() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:AppendEntriesRequest.leader)
  return _s;
}
inline const std::string& AppendEntriesRequest::_internal_leader() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leader_.Get();
}
inline void AppendEntriesRequest::_internal_set_leader(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leader_.Set(value, GetArena());
}
inline std::string* AppendEntriesRequest::_internal_mutable_leader() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.leader_.Mutable( GetArena());
}
inline std::string* AppendEntriesRequest::release_leader() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:AppendEntriesRequest.leader)
  return _impl_.leader_.Release();
}
inline void AppendEntriesRequest::set_allocated_leader(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leader_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.leader_.IsDefault()) {
          _impl_.leader_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppendEntriesRequest.leader)
}

// uint64 prev_log_entry = 4;
inline void AppendEntriesRequest::clear_prev_log_entry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prev_log_entry_ = ::uint64_t{0u};
}
inline ::uint64_t AppendEntriesRequest::prev_log_entry() const {
  // @@protoc_insertion_point(field_get:AppendEntriesRequest.prev_log_entry)
  return _internal_prev_log_entry();
}
inline void AppendEntriesRequest::set_prev_log_entry(::uint64_t value) {
  _internal_set_prev_log_entry(value);
  // @@protoc_insertion_point(field_set:AppendEntriesRequest.prev_log_entry)
}
inline ::uint64_t AppendEntriesRequest::_internal_prev_log_entry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prev_log_entry_;
}
inline void AppendEntriesRequest::_internal_set_prev_log_entry(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prev_log_entry_ = value;
}

// uint64 prev_log_term = 5;
inline void AppendEntriesRequest::clear_prev_log_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prev_log_term_ = ::uint64_t{0u};
}
inline ::uint64_t AppendEntriesRequest::prev_log_term() const {
  // @@protoc_insertion_point(field_get:AppendEntriesRequest.prev_log_term)
  return _internal_prev_log_term();
}
inline void AppendEntriesRequest::set_prev_log_term(::uint64_t value) {
  _internal_set_prev_log_term(value);
  // @@protoc_insertion_point(field_set:AppendEntriesRequest.prev_log_term)
}
inline ::uint64_t AppendEntriesRequest::_internal_prev_log_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prev_log_term_;
}
inline void AppendEntriesRequest::_internal_set_prev_log_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prev_log_term_ = value;
}

// repeated .Log entries = 6;
inline int AppendEntriesRequest::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int AppendEntriesRequest::entries_size() const {
  return _internal_entries_size();
}
inline void AppendEntriesRequest::clear_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entries_.Clear();
}
inline ::Log* AppendEntriesRequest::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:AppendEntriesRequest.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Log>* AppendEntriesRequest::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:AppendEntriesRequest.entries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entries();
}
inline const ::Log& AppendEntriesRequest::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AppendEntriesRequest.entries)
  return _internal_entries().Get(index);
}
inline ::Log* AppendEntriesRequest::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Log* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:AppendEntriesRequest.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Log>& AppendEntriesRequest::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:AppendEntriesRequest.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::Log>&
AppendEntriesRequest::_internal_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::Log>*
AppendEntriesRequest::_internal_mutable_entries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entries_;
}

// uint64 leader_commit_index = 7;
inline void AppendEntriesRequest::clear_leader_commit_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leader_commit_index_ = ::uint64_t{0u};
}
inline ::uint64_t AppendEntriesRequest::leader_commit_index() const {
  // @@protoc_insertion_point(field_get:AppendEntriesRequest.leader_commit_index)
  return _internal_leader_commit_index();
}
inline void AppendEntriesRequest::set_leader_commit_index(::uint64_t value) {
  _internal_set_leader_commit_index(value);
  // @@protoc_insertion_point(field_set:AppendEntriesRequest.leader_commit_index)
}
inline ::uint64_t AppendEntriesRequest::_internal_leader_commit_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leader_commit_index_;
}
inline void AppendEntriesRequest::_internal_set_leader_commit_index(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leader_commit_index_ = value;
}

// -------------------------------------------------------------------

// AppendEntriesResponse

// .RPCHeader rpc_header = 1;
inline bool AppendEntriesResponse::has_rpc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_header_ != nullptr);
  return value;
}
inline void AppendEntriesResponse::clear_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_header_ != nullptr) _impl_.rpc_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::RPCHeader& AppendEntriesResponse::_internal_rpc_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::RPCHeader* p = _impl_.rpc_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::RPCHeader&>(::_RPCHeader_default_instance_);
}
inline const ::RPCHeader& AppendEntriesResponse::rpc_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:AppendEntriesResponse.rpc_header)
  return _internal_rpc_header();
}
inline void AppendEntriesResponse::unsafe_arena_set_allocated_rpc_header(::RPCHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_header_);
  }
  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AppendEntriesResponse.rpc_header)
}
inline ::RPCHeader* AppendEntriesResponse::release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* released = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::RPCHeader* AppendEntriesResponse::unsafe_arena_release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:AppendEntriesResponse.rpc_header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* temp = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
  return temp;
}
inline ::RPCHeader* AppendEntriesResponse::_internal_mutable_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rpc_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::RPCHeader>(GetArena());
    _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(p);
  }
  return _impl_.rpc_header_;
}
inline ::RPCHeader* AppendEntriesResponse::mutable_rpc_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RPCHeader* _msg = _internal_mutable_rpc_header();
  // @@protoc_insertion_point(field_mutable:AppendEntriesResponse.rpc_header)
  return _msg;
}
inline void AppendEntriesResponse::set_allocated_rpc_header(::RPCHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::RPCHeader*>(_impl_.rpc_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::RPCHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:AppendEntriesResponse.rpc_header)
}

// uint64 term = 2;
inline void AppendEntriesResponse::clear_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.term_ = ::uint64_t{0u};
}
inline ::uint64_t AppendEntriesResponse::term() const {
  // @@protoc_insertion_point(field_get:AppendEntriesResponse.term)
  return _internal_term();
}
inline void AppendEntriesResponse::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:AppendEntriesResponse.term)
}
inline ::uint64_t AppendEntriesResponse::_internal_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.term_;
}
inline void AppendEntriesResponse::_internal_set_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.term_ = value;
}

// uint64 last_log = 3;
inline void AppendEntriesResponse::clear_last_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_log_ = ::uint64_t{0u};
}
inline ::uint64_t AppendEntriesResponse::last_log() const {
  // @@protoc_insertion_point(field_get:AppendEntriesResponse.last_log)
  return _internal_last_log();
}
inline void AppendEntriesResponse::set_last_log(::uint64_t value) {
  _internal_set_last_log(value);
  // @@protoc_insertion_point(field_set:AppendEntriesResponse.last_log)
}
inline ::uint64_t AppendEntriesResponse::_internal_last_log() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_log_;
}
inline void AppendEntriesResponse::_internal_set_last_log(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_log_ = value;
}

// bool success = 4;
inline void AppendEntriesResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool AppendEntriesResponse::success() const {
  // @@protoc_insertion_point(field_get:AppendEntriesResponse.success)
  return _internal_success();
}
inline void AppendEntriesResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:AppendEntriesResponse.success)
}
inline bool AppendEntriesResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void AppendEntriesResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// bool no_retry_backoff = 5;
inline void AppendEntriesResponse::clear_no_retry_backoff() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.no_retry_backoff_ = false;
}
inline bool AppendEntriesResponse::no_retry_backoff() const {
  // @@protoc_insertion_point(field_get:AppendEntriesResponse.no_retry_backoff)
  return _internal_no_retry_backoff();
}
inline void AppendEntriesResponse::set_no_retry_backoff(bool value) {
  _internal_set_no_retry_backoff(value);
  // @@protoc_insertion_point(field_set:AppendEntriesResponse.no_retry_backoff)
}
inline bool AppendEntriesResponse::_internal_no_retry_backoff() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.no_retry_backoff_;
}
inline void AppendEntriesResponse::_internal_set_no_retry_backoff(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.no_retry_backoff_ = value;
}

// -------------------------------------------------------------------

// RequestVoteRequest

// .RPCHeader rpc_header = 1;
inline bool RequestVoteRequest::has_rpc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_header_ != nullptr);
  return value;
}
inline void RequestVoteRequest::clear_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_header_ != nullptr) _impl_.rpc_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::RPCHeader& RequestVoteRequest::_internal_rpc_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::RPCHeader* p = _impl_.rpc_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::RPCHeader&>(::_RPCHeader_default_instance_);
}
inline const ::RPCHeader& RequestVoteRequest::rpc_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.rpc_header)
  return _internal_rpc_header();
}
inline void RequestVoteRequest::unsafe_arena_set_allocated_rpc_header(::RPCHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_header_);
  }
  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RequestVoteRequest.rpc_header)
}
inline ::RPCHeader* RequestVoteRequest::release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* released = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::RPCHeader* RequestVoteRequest::unsafe_arena_release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RequestVoteRequest.rpc_header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* temp = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
  return temp;
}
inline ::RPCHeader* RequestVoteRequest::_internal_mutable_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rpc_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::RPCHeader>(GetArena());
    _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(p);
  }
  return _impl_.rpc_header_;
}
inline ::RPCHeader* RequestVoteRequest::mutable_rpc_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RPCHeader* _msg = _internal_mutable_rpc_header();
  // @@protoc_insertion_point(field_mutable:RequestVoteRequest.rpc_header)
  return _msg;
}
inline void RequestVoteRequest::set_allocated_rpc_header(::RPCHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::RPCHeader*>(_impl_.rpc_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::RPCHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:RequestVoteRequest.rpc_header)
}

// uint64 term = 2;
inline void RequestVoteRequest::clear_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.term_ = ::uint64_t{0u};
}
inline ::uint64_t RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.term)
  return _internal_term();
}
inline void RequestVoteRequest::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.term)
}
inline ::uint64_t RequestVoteRequest::_internal_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.term_;
}
inline void RequestVoteRequest::_internal_set_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.term_ = value;
}

// bytes candidate = 3;
inline void RequestVoteRequest::clear_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_.ClearToEmpty();
}
inline const std::string& RequestVoteRequest::candidate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.candidate)
  return _internal_candidate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestVoteRequest::set_candidate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.candidate_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RequestVoteRequest.candidate)
}
inline std::string* RequestVoteRequest::mutable_candidate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:RequestVoteRequest.candidate)
  return _s;
}
inline const std::string& RequestVoteRequest::_internal_candidate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.candidate_.Get();
}
inline void RequestVoteRequest::_internal_set_candidate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.candidate_.Set(value, GetArena());
}
inline std::string* RequestVoteRequest::_internal_mutable_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.candidate_.Mutable( GetArena());
}
inline std::string* RequestVoteRequest::release_candidate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RequestVoteRequest.candidate)
  return _impl_.candidate_.Release();
}
inline void RequestVoteRequest::set_allocated_candidate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.candidate_.IsDefault()) {
          _impl_.candidate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RequestVoteRequest.candidate)
}

// uint64 last_log_index = 4;
inline void RequestVoteRequest::clear_last_log_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_log_index_ = ::uint64_t{0u};
}
inline ::uint64_t RequestVoteRequest::last_log_index() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.last_log_index)
  return _internal_last_log_index();
}
inline void RequestVoteRequest::set_last_log_index(::uint64_t value) {
  _internal_set_last_log_index(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.last_log_index)
}
inline ::uint64_t RequestVoteRequest::_internal_last_log_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_log_index_;
}
inline void RequestVoteRequest::_internal_set_last_log_index(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_log_index_ = value;
}

// uint64 last_log_term = 5;
inline void RequestVoteRequest::clear_last_log_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_log_term_ = ::uint64_t{0u};
}
inline ::uint64_t RequestVoteRequest::last_log_term() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.last_log_term)
  return _internal_last_log_term();
}
inline void RequestVoteRequest::set_last_log_term(::uint64_t value) {
  _internal_set_last_log_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.last_log_term)
}
inline ::uint64_t RequestVoteRequest::_internal_last_log_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_log_term_;
}
inline void RequestVoteRequest::_internal_set_last_log_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_log_term_ = value;
}

// bool leadership_transfer = 6;
inline void RequestVoteRequest::clear_leadership_transfer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leadership_transfer_ = false;
}
inline bool RequestVoteRequest::leadership_transfer() const {
  // @@protoc_insertion_point(field_get:RequestVoteRequest.leadership_transfer)
  return _internal_leadership_transfer();
}
inline void RequestVoteRequest::set_leadership_transfer(bool value) {
  _internal_set_leadership_transfer(value);
  // @@protoc_insertion_point(field_set:RequestVoteRequest.leadership_transfer)
}
inline bool RequestVoteRequest::_internal_leadership_transfer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leadership_transfer_;
}
inline void RequestVoteRequest::_internal_set_leadership_transfer(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leadership_transfer_ = value;
}

// -------------------------------------------------------------------

// RequestVoteResponse

// .RPCHeader rpc_header = 1;
inline bool RequestVoteResponse::has_rpc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_header_ != nullptr);
  return value;
}
inline void RequestVoteResponse::clear_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_header_ != nullptr) _impl_.rpc_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::RPCHeader& RequestVoteResponse::_internal_rpc_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::RPCHeader* p = _impl_.rpc_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::RPCHeader&>(::_RPCHeader_default_instance_);
}
inline const ::RPCHeader& RequestVoteResponse::rpc_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.rpc_header)
  return _internal_rpc_header();
}
inline void RequestVoteResponse::unsafe_arena_set_allocated_rpc_header(::RPCHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_header_);
  }
  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RequestVoteResponse.rpc_header)
}
inline ::RPCHeader* RequestVoteResponse::release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* released = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::RPCHeader* RequestVoteResponse::unsafe_arena_release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RequestVoteResponse.rpc_header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* temp = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
  return temp;
}
inline ::RPCHeader* RequestVoteResponse::_internal_mutable_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rpc_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::RPCHeader>(GetArena());
    _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(p);
  }
  return _impl_.rpc_header_;
}
inline ::RPCHeader* RequestVoteResponse::mutable_rpc_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RPCHeader* _msg = _internal_mutable_rpc_header();
  // @@protoc_insertion_point(field_mutable:RequestVoteResponse.rpc_header)
  return _msg;
}
inline void RequestVoteResponse::set_allocated_rpc_header(::RPCHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::RPCHeader*>(_impl_.rpc_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::RPCHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:RequestVoteResponse.rpc_header)
}

// uint64 term = 2;
inline void RequestVoteResponse::clear_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.term_ = ::uint64_t{0u};
}
inline ::uint64_t RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.term)
  return _internal_term();
}
inline void RequestVoteResponse::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RequestVoteResponse.term)
}
inline ::uint64_t RequestVoteResponse::_internal_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.term_;
}
inline void RequestVoteResponse::_internal_set_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.term_ = value;
}

// bytes peers = 3;
inline void RequestVoteResponse::clear_peers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peers_.ClearToEmpty();
}
inline const std::string& RequestVoteResponse::peers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.peers)
  return _internal_peers();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RequestVoteResponse::set_peers(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.peers_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RequestVoteResponse.peers)
}
inline std::string* RequestVoteResponse::mutable_peers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_peers();
  // @@protoc_insertion_point(field_mutable:RequestVoteResponse.peers)
  return _s;
}
inline const std::string& RequestVoteResponse::_internal_peers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.peers_.Get();
}
inline void RequestVoteResponse::_internal_set_peers(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.peers_.Set(value, GetArena());
}
inline std::string* RequestVoteResponse::_internal_mutable_peers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.peers_.Mutable( GetArena());
}
inline std::string* RequestVoteResponse::release_peers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RequestVoteResponse.peers)
  return _impl_.peers_.Release();
}
inline void RequestVoteResponse::set_allocated_peers(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peers_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.peers_.IsDefault()) {
          _impl_.peers_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RequestVoteResponse.peers)
}

// bool granted = 4;
inline void RequestVoteResponse::clear_granted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.granted_ = false;
}
inline bool RequestVoteResponse::granted() const {
  // @@protoc_insertion_point(field_get:RequestVoteResponse.granted)
  return _internal_granted();
}
inline void RequestVoteResponse::set_granted(bool value) {
  _internal_set_granted(value);
  // @@protoc_insertion_point(field_set:RequestVoteResponse.granted)
}
inline bool RequestVoteResponse::_internal_granted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.granted_;
}
inline void RequestVoteResponse::_internal_set_granted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.granted_ = value;
}

// -------------------------------------------------------------------

// TimeoutNowRequest

// .RPCHeader rpc_header = 1;
inline bool TimeoutNowRequest::has_rpc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_header_ != nullptr);
  return value;
}
inline void TimeoutNowRequest::clear_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_header_ != nullptr) _impl_.rpc_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::RPCHeader& TimeoutNowRequest::_internal_rpc_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::RPCHeader* p = _impl_.rpc_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::RPCHeader&>(::_RPCHeader_default_instance_);
}
inline const ::RPCHeader& TimeoutNowRequest::rpc_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TimeoutNowRequest.rpc_header)
  return _internal_rpc_header();
}
inline void TimeoutNowRequest::unsafe_arena_set_allocated_rpc_header(::RPCHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_header_);
  }
  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TimeoutNowRequest.rpc_header)
}
inline ::RPCHeader* TimeoutNowRequest::release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* released = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::RPCHeader* TimeoutNowRequest::unsafe_arena_release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TimeoutNowRequest.rpc_header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* temp = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
  return temp;
}
inline ::RPCHeader* TimeoutNowRequest::_internal_mutable_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rpc_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::RPCHeader>(GetArena());
    _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(p);
  }
  return _impl_.rpc_header_;
}
inline ::RPCHeader* TimeoutNowRequest::mutable_rpc_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RPCHeader* _msg = _internal_mutable_rpc_header();
  // @@protoc_insertion_point(field_mutable:TimeoutNowRequest.rpc_header)
  return _msg;
}
inline void TimeoutNowRequest::set_allocated_rpc_header(::RPCHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::RPCHeader*>(_impl_.rpc_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::RPCHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:TimeoutNowRequest.rpc_header)
}

// -------------------------------------------------------------------

// TimeoutNowResponse

// .RPCHeader rpc_header = 1;
inline bool TimeoutNowResponse::has_rpc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_header_ != nullptr);
  return value;
}
inline void TimeoutNowResponse::clear_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_header_ != nullptr) _impl_.rpc_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::RPCHeader& TimeoutNowResponse::_internal_rpc_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::RPCHeader* p = _impl_.rpc_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::RPCHeader&>(::_RPCHeader_default_instance_);
}
inline const ::RPCHeader& TimeoutNowResponse::rpc_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:TimeoutNowResponse.rpc_header)
  return _internal_rpc_header();
}
inline void TimeoutNowResponse::unsafe_arena_set_allocated_rpc_header(::RPCHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_header_);
  }
  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TimeoutNowResponse.rpc_header)
}
inline ::RPCHeader* TimeoutNowResponse::release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* released = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::RPCHeader* TimeoutNowResponse::unsafe_arena_release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:TimeoutNowResponse.rpc_header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* temp = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
  return temp;
}
inline ::RPCHeader* TimeoutNowResponse::_internal_mutable_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rpc_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::RPCHeader>(GetArena());
    _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(p);
  }
  return _impl_.rpc_header_;
}
inline ::RPCHeader* TimeoutNowResponse::mutable_rpc_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RPCHeader* _msg = _internal_mutable_rpc_header();
  // @@protoc_insertion_point(field_mutable:TimeoutNowResponse.rpc_header)
  return _msg;
}
inline void TimeoutNowResponse::set_allocated_rpc_header(::RPCHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::RPCHeader*>(_impl_.rpc_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::RPCHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:TimeoutNowResponse.rpc_header)
}

// -------------------------------------------------------------------

// InstallSnapshotRequest

// .RPCHeader rpc_header = 1;
inline bool InstallSnapshotRequest::has_rpc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_header_ != nullptr);
  return value;
}
inline void InstallSnapshotRequest::clear_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_header_ != nullptr) _impl_.rpc_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::RPCHeader& InstallSnapshotRequest::_internal_rpc_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::RPCHeader* p = _impl_.rpc_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::RPCHeader&>(::_RPCHeader_default_instance_);
}
inline const ::RPCHeader& InstallSnapshotRequest::rpc_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.rpc_header)
  return _internal_rpc_header();
}
inline void InstallSnapshotRequest::unsafe_arena_set_allocated_rpc_header(::RPCHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_header_);
  }
  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InstallSnapshotRequest.rpc_header)
}
inline ::RPCHeader* InstallSnapshotRequest::release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* released = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::RPCHeader* InstallSnapshotRequest::unsafe_arena_release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:InstallSnapshotRequest.rpc_header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* temp = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
  return temp;
}
inline ::RPCHeader* InstallSnapshotRequest::_internal_mutable_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rpc_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::RPCHeader>(GetArena());
    _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(p);
  }
  return _impl_.rpc_header_;
}
inline ::RPCHeader* InstallSnapshotRequest::mutable_rpc_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RPCHeader* _msg = _internal_mutable_rpc_header();
  // @@protoc_insertion_point(field_mutable:InstallSnapshotRequest.rpc_header)
  return _msg;
}
inline void InstallSnapshotRequest::set_allocated_rpc_header(::RPCHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::RPCHeader*>(_impl_.rpc_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::RPCHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:InstallSnapshotRequest.rpc_header)
}

// int64 snapshot_version = 11;
inline void InstallSnapshotRequest::clear_snapshot_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_version_ = ::int64_t{0};
}
inline ::int64_t InstallSnapshotRequest::snapshot_version() const {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.snapshot_version)
  return _internal_snapshot_version();
}
inline void InstallSnapshotRequest::set_snapshot_version(::int64_t value) {
  _internal_set_snapshot_version(value);
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.snapshot_version)
}
inline ::int64_t InstallSnapshotRequest::_internal_snapshot_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_version_;
}
inline void InstallSnapshotRequest::_internal_set_snapshot_version(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_version_ = value;
}

// uint64 term = 2;
inline void InstallSnapshotRequest::clear_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.term_ = ::uint64_t{0u};
}
inline ::uint64_t InstallSnapshotRequest::term() const {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.term)
  return _internal_term();
}
inline void InstallSnapshotRequest::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.term)
}
inline ::uint64_t InstallSnapshotRequest::_internal_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.term_;
}
inline void InstallSnapshotRequest::_internal_set_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.term_ = value;
}

// bytes leader = 3;
inline void InstallSnapshotRequest::clear_leader() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leader_.ClearToEmpty();
}
inline const std::string& InstallSnapshotRequest::leader() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.leader)
  return _internal_leader();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallSnapshotRequest::set_leader(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leader_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.leader)
}
inline std::string* InstallSnapshotRequest::mutable_leader() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:InstallSnapshotRequest.leader)
  return _s;
}
inline const std::string& InstallSnapshotRequest::_internal_leader() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leader_.Get();
}
inline void InstallSnapshotRequest::_internal_set_leader(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leader_.Set(value, GetArena());
}
inline std::string* InstallSnapshotRequest::_internal_mutable_leader() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.leader_.Mutable( GetArena());
}
inline std::string* InstallSnapshotRequest::release_leader() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:InstallSnapshotRequest.leader)
  return _impl_.leader_.Release();
}
inline void InstallSnapshotRequest::set_allocated_leader(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leader_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.leader_.IsDefault()) {
          _impl_.leader_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstallSnapshotRequest.leader)
}

// uint64 last_log_index = 4;
inline void InstallSnapshotRequest::clear_last_log_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_log_index_ = ::uint64_t{0u};
}
inline ::uint64_t InstallSnapshotRequest::last_log_index() const {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.last_log_index)
  return _internal_last_log_index();
}
inline void InstallSnapshotRequest::set_last_log_index(::uint64_t value) {
  _internal_set_last_log_index(value);
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.last_log_index)
}
inline ::uint64_t InstallSnapshotRequest::_internal_last_log_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_log_index_;
}
inline void InstallSnapshotRequest::_internal_set_last_log_index(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_log_index_ = value;
}

// uint64 last_log_term = 5;
inline void InstallSnapshotRequest::clear_last_log_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_log_term_ = ::uint64_t{0u};
}
inline ::uint64_t InstallSnapshotRequest::last_log_term() const {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.last_log_term)
  return _internal_last_log_term();
}
inline void InstallSnapshotRequest::set_last_log_term(::uint64_t value) {
  _internal_set_last_log_term(value);
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.last_log_term)
}
inline ::uint64_t InstallSnapshotRequest::_internal_last_log_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_log_term_;
}
inline void InstallSnapshotRequest::_internal_set_last_log_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_log_term_ = value;
}

// bytes peers = 6;
inline void InstallSnapshotRequest::clear_peers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peers_.ClearToEmpty();
}
inline const std::string& InstallSnapshotRequest::peers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.peers)
  return _internal_peers();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallSnapshotRequest::set_peers(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.peers_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.peers)
}
inline std::string* InstallSnapshotRequest::mutable_peers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_peers();
  // @@protoc_insertion_point(field_mutable:InstallSnapshotRequest.peers)
  return _s;
}
inline const std::string& InstallSnapshotRequest::_internal_peers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.peers_.Get();
}
inline void InstallSnapshotRequest::_internal_set_peers(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.peers_.Set(value, GetArena());
}
inline std::string* InstallSnapshotRequest::_internal_mutable_peers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.peers_.Mutable( GetArena());
}
inline std::string* InstallSnapshotRequest::release_peers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:InstallSnapshotRequest.peers)
  return _impl_.peers_.Release();
}
inline void InstallSnapshotRequest::set_allocated_peers(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.peers_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.peers_.IsDefault()) {
          _impl_.peers_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstallSnapshotRequest.peers)
}

// bytes configuration = 7;
inline void InstallSnapshotRequest::clear_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.configuration_.ClearToEmpty();
}
inline const std::string& InstallSnapshotRequest::configuration() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.configuration)
  return _internal_configuration();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallSnapshotRequest::set_configuration(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.configuration_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.configuration)
}
inline std::string* InstallSnapshotRequest::mutable_configuration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:InstallSnapshotRequest.configuration)
  return _s;
}
inline const std::string& InstallSnapshotRequest::_internal_configuration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.configuration_.Get();
}
inline void InstallSnapshotRequest::_internal_set_configuration(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.configuration_.Set(value, GetArena());
}
inline std::string* InstallSnapshotRequest::_internal_mutable_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.configuration_.Mutable( GetArena());
}
inline std::string* InstallSnapshotRequest::release_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:InstallSnapshotRequest.configuration)
  return _impl_.configuration_.Release();
}
inline void InstallSnapshotRequest::set_allocated_configuration(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.configuration_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.configuration_.IsDefault()) {
          _impl_.configuration_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstallSnapshotRequest.configuration)
}

// uint64 configuration_index = 8;
inline void InstallSnapshotRequest::clear_configuration_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.configuration_index_ = ::uint64_t{0u};
}
inline ::uint64_t InstallSnapshotRequest::configuration_index() const {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.configuration_index)
  return _internal_configuration_index();
}
inline void InstallSnapshotRequest::set_configuration_index(::uint64_t value) {
  _internal_set_configuration_index(value);
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.configuration_index)
}
inline ::uint64_t InstallSnapshotRequest::_internal_configuration_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.configuration_index_;
}
inline void InstallSnapshotRequest::_internal_set_configuration_index(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.configuration_index_ = value;
}

// int64 size = 9;
inline void InstallSnapshotRequest::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = ::int64_t{0};
}
inline ::int64_t InstallSnapshotRequest::size() const {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.size)
  return _internal_size();
}
inline void InstallSnapshotRequest::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.size)
}
inline ::int64_t InstallSnapshotRequest::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void InstallSnapshotRequest::_internal_set_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// bytes data = 10;
inline void InstallSnapshotRequest::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& InstallSnapshotRequest::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InstallSnapshotRequest.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallSnapshotRequest::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:InstallSnapshotRequest.data)
}
inline std::string* InstallSnapshotRequest::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:InstallSnapshotRequest.data)
  return _s;
}
inline const std::string& InstallSnapshotRequest::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void InstallSnapshotRequest::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* InstallSnapshotRequest::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* InstallSnapshotRequest::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:InstallSnapshotRequest.data)
  return _impl_.data_.Release();
}
inline void InstallSnapshotRequest::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstallSnapshotRequest.data)
}

// -------------------------------------------------------------------

// InstallSnapshotResponse

// .RPCHeader rpc_header = 1;
inline bool InstallSnapshotResponse::has_rpc_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rpc_header_ != nullptr);
  return value;
}
inline void InstallSnapshotResponse::clear_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rpc_header_ != nullptr) _impl_.rpc_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::RPCHeader& InstallSnapshotResponse::_internal_rpc_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::RPCHeader* p = _impl_.rpc_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::RPCHeader&>(::_RPCHeader_default_instance_);
}
inline const ::RPCHeader& InstallSnapshotResponse::rpc_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:InstallSnapshotResponse.rpc_header)
  return _internal_rpc_header();
}
inline void InstallSnapshotResponse::unsafe_arena_set_allocated_rpc_header(::RPCHeader* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rpc_header_);
  }
  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InstallSnapshotResponse.rpc_header)
}
inline ::RPCHeader* InstallSnapshotResponse::release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* released = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::RPCHeader* InstallSnapshotResponse::unsafe_arena_release_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:InstallSnapshotResponse.rpc_header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::RPCHeader* temp = _impl_.rpc_header_;
  _impl_.rpc_header_ = nullptr;
  return temp;
}
inline ::RPCHeader* InstallSnapshotResponse::_internal_mutable_rpc_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rpc_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::RPCHeader>(GetArena());
    _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(p);
  }
  return _impl_.rpc_header_;
}
inline ::RPCHeader* InstallSnapshotResponse::mutable_rpc_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::RPCHeader* _msg = _internal_mutable_rpc_header();
  // @@protoc_insertion_point(field_mutable:InstallSnapshotResponse.rpc_header)
  return _msg;
}
inline void InstallSnapshotResponse::set_allocated_rpc_header(::RPCHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::RPCHeader*>(_impl_.rpc_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::RPCHeader*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rpc_header_ = reinterpret_cast<::RPCHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:InstallSnapshotResponse.rpc_header)
}

// uint64 term = 2;
inline void InstallSnapshotResponse::clear_term() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.term_ = ::uint64_t{0u};
}
inline ::uint64_t InstallSnapshotResponse::term() const {
  // @@protoc_insertion_point(field_get:InstallSnapshotResponse.term)
  return _internal_term();
}
inline void InstallSnapshotResponse::set_term(::uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:InstallSnapshotResponse.term)
}
inline ::uint64_t InstallSnapshotResponse::_internal_term() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.term_;
}
inline void InstallSnapshotResponse::_internal_set_term(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.term_ = value;
}

// bool success = 3;
inline void InstallSnapshotResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool InstallSnapshotResponse::success() const {
  // @@protoc_insertion_point(field_get:InstallSnapshotResponse.success)
  return _internal_success();
}
inline void InstallSnapshotResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:InstallSnapshotResponse.success)
}
inline bool InstallSnapshotResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void InstallSnapshotResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::Log_LogType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Log_LogType>() {
  return ::Log_LogType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_transport_2eproto_2epb_2eh
